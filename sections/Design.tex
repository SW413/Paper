\chapter{Design}
\label{cha:Design}
%Metatext for design chapter
In this chapter the design of the languange will be represented.
First the philosophy for the languange will be introduced to clarify what this languange is attempting to acheive.
The philosophy will lead to some attributes being more important than others, the choices we deem the more impactful ones will also be documented in this chapter.

\input{sections/philosophy.tex}

\section{Generel}
\textbf{Character set}
Source code must be in Unicode.
This is chosen even though all variables and types is in ACSI, because Unicode gives the programmer of different origins the possibility to use special characters of theirs first language.
An example of this would be the danish %\"\Æ,\Ø,\Å\".

\textbf{Comments}
Comments are done as in other large languages i.e. C and Java, with the use of \"\/\/\".
The compiler ignores everything from \"\/\/\" to the end of the line.
The decision  to use already existing solutions is to make sure the language is easy to learn if the programmer already have some coding experience.
Below on \myref{lst:CommSemi} a snippet of an comment in use can be seen.

\textbf{Semicolon}
A semicolon \"\;\" is used as a terminator and are required after every statement.
This is again based on other already existing languages such as Java and the C family.
The use of terminators in a language is of less importance, and therefore we decide that a semicolon is required to terminate each statement for easier readability.
The use of semicolon can also be found on \myref{lst:CommSemi}.


\begin{lstlisting}[caption={Comment and Semicolon},label={lst:CommSemi}]
int a = 1;		//initialization with specified type.
\end{lstlisting}

\textbf{Case Sensitivity}
The language is case sensitive to make sure the programmer uses whatever convention he is most use to, and pleased with.
C\# uses case sensitivity to i.e. allow the programmer to separate class names and instances.
Having a case sensitive language provide a higher readability and writability since the programmer are use to writing English or other spoken language which are case sensitivity.

\textbf{Ignored characters}
The language is a free-form language, which means all whitespace is ignored.
Whitespace includes, space, tabs and line feed.
Whitespace is ignored so it easier to organise the source code to achieve a higher level of readability.

\textbf{Scope}
\todo{Scope rules?}

\textbf{Operators}
Available operators in the language can be found on \ref{tbl:operators} with a short description.
\input{figures/Operators.tex}  

\textbf{Structure} 


\section{Type and variables}
%http://www.informit.com/articles/article.aspx?p=2103809&seqNum=3
GAMBLE uses three primitive data types; integers(int), floating points(float) and boolean values(bool), as well as two composite data types; matrices and vector.

\textbf{Integers and floating points}
Integers default to 32bit and the same goes for floating points, it is possible to declare them of another bit size; 16bit and 64bit are valid alternatives in case such should be needed.%Gør vi faktisk dette - im not sure?
The time sink of using the GPU is the overhead data transfer from the CPU to the GPU, as such having the data types declarable in smaller bit sizes allows the programmer to determine what bit size is really needed.
Thus awards the programmer the ability to optimize their computations while taking the data transfer into account.

\textbf{Booleans}
In a languange such as C, booleans are represented by integers where 0 evaluates to false.
To enhance readability and avoid the booleans acting as integers, they are given their own data type, where the meaning is clear by it being either true or false.

\textbf{Matrices}
The two composite data types provided by GAMBLE are representations of matrices and vectors from linear algebra.
A matrice can be of size n by m where n represents rows and m represents columns.
Each row correlates to a row vector, vectors exist both as row and column vectors.
As such a matrice can be seen as a number n of stacked row vectors, which happen to have the same representation as arrays do in C-like languanges i.e vectors can be seen as a type of array, and matrices as multiple arrays.

\textbf{Vectors}
The vectors are a subset of matrices, as such they are represented in a similar fashion.
%Det kunne eventuelt give mening at lave et table over hvordan vi repræsentere data(bitwise)??

\section{Functions}
This section will describe GAMBLE's use of functions. 
Like in many other languages it is possible to declare your own functions in GAMBLE.
This is useful for organising code, and reusing parts of the sourcecode.

\subsection{Function identifiers}
When identifying a function is is required to write the body of the function.
If function identifiers were spread out all over the document it could be hard to find where certain elements of the code were.
In C it is possible to make prototypes of functions in the top of the document, and then declare the bodies of the functions in other places of the document. 
This is not possible in GAMBLE because of the increase in readability.
A function identifier is exactly like C, with the \texttt{return type} then the \texttt{functionname}, \texttt{(formal parameters)} and finally \texttt{\{body\}}.
The function body can contain a number of statements and various controlflows.
Furthermore it can contain calls to other functions or calls to the function itself, and hereby recursion is a possibility in GAMBLE
An example of a function identifier can be seen on \myref{functionID}.
Other syntaxes could have been used, but not only is this the way C does it, it is also widely used in many other languages like C\# and Java.

\begin{lstlisting}[label=functionID]                                                             
int add(int a, int b){
	return a + b;
}
\end{lstlisting}

\subsection{Function calls}
When you have made a function, you need to call the function as well.
This is done again exactly like in C, where you call a function by writing its name followed by the formal parameters in parenthesis.
This is a widely used way of calling functions in many languages just like the identification was.
An example can be seen on \myref{functionCall}.

\begin{lstlisting}[label=functionCall]
add(4, 3);
\end{lstlisting}


\subsection{Return value}
Functions have a return value which can be seen on \myref{functionID}.
The return values are all the types in GAMBLE mentioned in \myref{Types} and then void. 
A void function will not return anything, but instead can be seen as a procedure which manipulates its input, and perhaps prints something.
This choice was made because GAMBLE should to be able to return all the different types in the language from a function, but also be able to perform these procedures which a void function may do.
GAMBLE assigns return values from a function just like it assigns other values to variables.
The value or type to be returned is preceded by the keyword \texttt{return}, just like it is in C and other C-like languages.
An example can be seen on \myref{returnFunction}.

\begin{lstlisting}[label=returnFunction]
int a = 0;

a = add(4, 3);
\end{lstlisting}

\subsection{Premade functions (rename)}\todo{This} 
%\section{Control Flow}
%\textbf{For-loop}
%\textbf{While-loop}
%\textbf{If \& If else}

%% OLD
%\input{sections/subsections/controlflow.tex}
%% New
\input{sections/subsections/controlflow2.tex}

