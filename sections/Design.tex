\chapter{Design}
\label{cha:Design}
%Metatext for design chapter
In this chapter the design of the language will be represented.
First the philosophy for the language will be introduced to clarify what this language is attempting to achieve.
The philosophy will lead to some attributes being more important than others, the choices we deem the more impactful ones will also be documented in this chapter.

\input{sections/philosophy.tex}

In the following sections different parts of GAMBLE will be investigated.

\section{Core syntax choices}

\subsection*{Character set}
Source code must be in Unicode.
This is chosen even though all variables and types is in ASCII, because Unicode gives the programmer of different origins the possibility to use special characters of their first language.
An example of this would be the danish %\"\Æ,\Ø,\Å\".

\subsection*{Comments}
Comments are done as in other large languages i.e. C and Java, with the use of \"\/\/\".
The compiler ignores everything from \"\/\/\" to the end of line(EOL).
The decision to use already existing solutions is to make sure the language is easy to learn if the programmer already have some coding experience.
On \myref{lst:CommSemi} a snippet of a comment in use can be seen.

\subsection*{Semicolon}
A semicolon \"\;\" is used as a terminator and are required after every statement.
This is again based on other already existing languages such as Java and the C family.
The use of terminators in a language is of less importance, and therefore we decide that a semicolon is required to terminate each statement for easier readability.
The use of semicolon can also be found on \myref{lst:CommSemi}.

\begin{lstlisting}[caption={Comment and Semicolon},label={lst:CommSemi}]
int a = 1; //initialization with specified type.
\end{lstlisting}

\subsection*{Case Sensitivity}
The language is case sensitive to make sure the programmer uses whatever convention he or she is most used to, and pleased with.
C\# uses case sensitivity to i.e. allow the programmer to separate class names and instances.
Having a case sensitive language provides a higher readability and writability since the programmer is used to writing English or other spoken language which are case sensitive.

\subsection*{Ignored characters}
The language is a free-form language, which means all whitespace is ignored.
Whitespace includes, space, tabs and line feed.
Whitespace is ignored and have no meaning in the sourcecode, which makes it easier to organise the source code to achieve a higher level of readability.

\subsection*{Scope}
GAMBLE uses static scoping like you find in many modern programming languages like C\# and Java, and also in C.
This gives better readability and writability, since it easier to have an understanding on what the call-stack will look like, in order to determine what different variables are in scope.
The curly brackets \texttt{\{\}}, can be used to make a new block in the sourcecode.

\subsection*{Operators}
Available operators in the language can be found on \ref{tbl:operators} with a short description.
\input{figures/Operators.tex}  
It is not possible to use operators with matrices or vectors, functions which support different operations on these types will be included in a library.

\subsection*{Structure} 
The structure of a GAMBLE file is seen on \myref{lst:Structure}.

\begin{lstlisting}[caption={The structure of GABMLE files},label={lst:Structure}]
Including different libraries

Function declarations

Statements

EOF
\end{lstlisting}

With this structure GAMBLE reaches a high level of readability, since all the files are structured in the same way.
In languages like C\# and Java, a class can be written with any structure, which can result in files which are very difficult to read.
GAMBLE aims for high readability, which is the reasoning behind this choice.

\section{Type and variables}
%http://www.informit.com/articles/article.aspx?p=210380l9&seqNum=3
GAMBLE uses three primitive data types; integers(int), floating points(float) and boolean values(bool), as well as two composite data types; matrices and vector.

\subsection{Integers and floating points}
Integers default to 32bit and the same goes for floating points, it is possible to declare them of another bit size; 16bit and 64bit are valid alternatives in case such would be needed.%Gør vi faktisk dette - im not sure?
The time sink of using the GPU is the overhead data transfer from the CPU to the GPU, as such having the data types declarable in smaller bit sizes allows the programmer to determine what bit size is really needed.
Thus awards the programmer the ability to optimize their computations while taking the data transfer into account.
Integers are restricted to whole numbers, both negative and positive.
Integers is shortened to int for easier writing.
Floating points are decimals numbers which can be both negative and positive.
Floating points is shortened to float for easier writing as well.

\subsection{Booleans}
In a language such as C, booleans are represented by integers where 0 evaluates to false and everything else evaluates to true.
To enhance readability and avoid the booleans acting as integers, they are given their own data type, where the meaning is clear by it being either true or false.
GAMBLE have booleans implemented because it is needed in control flows and give an advangtange compared to using integers or floats for stats verification.   

\subsection{Matrices and vectors}
The two composite data types provided by GAMBLE are representations of matrices and vectors from linear algebra.
A matrix can be of size n by m where n represents rows and m represents columns.
Each row correlates to a row vector, vectors exist both as row and column vectors.
As such a matrix can be seen as a number n of stacked row vectors, which happen to have the same representation as arrays do in C-like languages i.e vectors can be seen as a type of array, and matrices as multiple arrays.
The vectors are a subset of matrices, as such they are represented in a similar fashion.
An example of an matrix can be seen on \myref{lst:matrix}.

\begin{lstlisting}[caption={Creating a matrix},label={lst:matrix}]
imatrix m[2,2] = [1, 0; 0, 1] //prefix [i|f|b] can be used to make a corrosponding int, float or boolean matrix.

//Alternatives
matrix m;
m = mkMatrix(int, 5, 5); //making a 5x5 matrix accepting integers.
\end{lstlisting}


\section{Functions}
\textbf{Function identifiers}
\textbf{Function calls}
\textbf{Return value}
\textbf{Premade functions (rename)}

%\section{Control Flow}
%\textbf{For-loop}
%\textbf{While-loop}
%\textbf{If \& If else}

%% OLD
%\input{sections/subsections/controlflow.tex}
%% New
\input{sections/subsections/controlflow2.tex}

