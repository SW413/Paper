\chapter{Semantics}
In this section the semantics for \gls{gamble} will be shown and explained.
Operational semantics is necessary to provide detailed information about the mathematical operations behind the language.
There exist two way of showing operational semantics for a language.
Natural semantics (big-step semantics) and structural operational semantics (small-step semantics), it is deiced to use big-step semantics.
The semantics is organized as follow:

\begin{align*}
	\textbf{a} \in  &Arithmetic\quad expression\\
	\textbf{v} \in  &Variable\\
	\textbf{m} \in  &Matrix\\
	\textbf{vec} \in  &Vector\\
\end{align*}

\textbf{v} is meant to store the result, this can be both a value, a vector or a matrix.
Every big-step semantic showing operations on a matrix, is also possible to perform on a vector, which evaluate to a one-dimension matrix.
Every big-step semantic showing operations on a vector can not be used on a matrix, since it requires the dimensions to fit those of a one-dimension vector.

The variable environment(${ e }_{ v }$) is a function that for each variable define to which storage location it is bound to. A variable environment corresponds to a symbol table.
The store ($st$) is a function that for each storage location tells us which value is stored in the location. A store corresponds to a complete description of the contents of the memory.\citep{EnvSt_Semantics}

A few of the big-step semantics for \gls{gamble} is included in this chapter, semantics for the rest of the language is seen \myref{app:semantics}.
%The most few most important operational semantics there will be explained is, Variable declaration, Statements assignment, Matrix declaration, Matrix- Matrix Multiplication and Scalar product.
A few of the most important and interesting operational semantics there will be explained is, variable declaration, statements assignment, matrix declaration, , matrix product and scalar product.

\subsection*{Declaring Variables}
Any non-empty variable declaration will modify the variable environment since the new variables will be bound to the new location.
A variable declaration will also modify the store, since the new location will be initialised to contain the initial values of the new variables.
The transition relation describing variable declarations defines a big-step semantic, since the allocation of new address space for newly declared variables is an invisible operation.

\subsubsection{Variable declaration}
\begin{equation}
	\frac { <{ D }_{ v },{ e }_{ v }^{ `` },st[\iota \mapsto v]>{ \rightarrow  }_{ Dv }<{ e }_{ v }^{ ` },{ st }^{ ` }> }{ <var\quad x:=a;Dv,{ e }_{ v }st>{ \rightarrow  }_{ Dv }<{ e }_{ v }^{ ` },{ st }^{ ` }> }
\end{equation}

\subsection*{Statements}
The effect of a statement is that the store may change, since a statement may modify the values of variables involved through assignments.
A statement should not modify the variable environment.
We define a BS-semantic for statements (except procedure calls)

\subsubsection{Assignment}
\begin{align*}
	&{ e }_{ v }\vdash <x=a,st>\rightarrow st[\iota \mapsto v]\\
	where\quad &{ e }_{ v },st\vdash a{ \rightarrow  }_{ A }v\quad and\quad  { e }_{ v }(x)=\iota 
\end{align*}

\subsection*{Matrices and Vectors}
A matrix is referred to as seen below, the superscript is referred to as the index of the matrix, while the subscript is the size of the matrix.
\begin{align*}
	\begin{bmatrix} { { m }_{ 1,1 }^{ n } } & { { m }_{ 1,2 }^{ n } } & \dots  & { m }_{ j,1 }^{ n } \\
{ { m }_{ 2,1 }^{ n } }  &  { { m }_{ 2,2 }^{ n } } & \dots & \vdots
\\ \vdots  & \vdots & \ddots  & \vdots \\
 { m }_{ 1,k }^{ n } & \dots & \dots & { m }_{ j,k }^{ n } \end{bmatrix}
\end{align*}

\subsubsection{Matrix declaration}
\begin{equation}
	\frac { { e }_{ v },st\vdash j{ \rightarrow  }_{ A }{ v }_{ 1 }\quad { e }_{ v },st\vdash k{ \rightarrow  }_{ A }{ v }_{ 2 } }{ { M }^{ 1 }\quad =\quad martix<int|float|bool>[{ v }_{ 1 },{ v }_{ 2 }]\rightarrow { st }^{ ` },{ e }_{ v } } ,{ M }^{ 1 }[{ v }_{ 1 },{ v }_{ 2 }]=\begin{bmatrix} { 0 } & \dots  & 0 \\ \vdots  & \ddots  &  \\ 0 &  & 0 \end{bmatrix}
	\end{equation}

\subsubsection{Matrix product}
\begin{equation}
	\frac { { e }_{ v },st\vdash { M }^{ 1 }{ \rightarrow  }_{ A }{ v }_{ 1 }\quad { e }_{ v },st\vdash { M }^{ 2 }{ \rightarrow  }_{ A }{ v }_{ 2 } }{ { e }_{ v },st\vdash { M }^{ 1 }*{ M }^{ 2 }{ \rightarrow  }_{ A }{ v } } ,\begin{matrix} { v }_{ 1 }=matrix<>[j,k] \\ { v }_{ 2 }=matrix<>[k,l] \\ v={ v }_{ 1 }*{ v }_{ 2 } \end{matrix}
\end{equation}

\subsubsection{Scalar product}
\begin{equation}
	\frac { { e }_{ v },st\vdash { M }^{ 1 }{ \rightarrow  }_{ A }{ v }_{ 1 }\quad { e }_{ v },st\vdash { a }_{ 1 }{ \rightarrow  }_{ A }{ v }_{ 2 } }{ { e }_{ v },st\vdash { M }^{ 1 }\ast { a }_{ 1 }{ \rightarrow  }_{ A }{ v } } ,\begin{matrix} { v }_{ 1 }=matrix<>[j,k] \\ { v }_{ 2 }={ a }_{ 1 } \\ v=\begin{bmatrix} { { a }_{ 1 }*m }_{ 1,1 }^{ 1 } & \dots  & { { a }_{ 1 }*m }_{ j,1 }^{ 1 } \\ \vdots  & \ddots  &  \\ { { a }_{ 1 }*m }_{ 1,k }^{ 1 } &  & { { a }_{ 1 }*m }_{ j,k }^{ 1 } \end{bmatrix} \end{matrix}
\end{equation}

