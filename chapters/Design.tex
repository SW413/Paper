\chapter{Design}
\label{cha:Design}
%Metatext for design chapter
In this chapter the design of the language will be represented.
First the philosophy for the language will be introduced to clarify what this language is attempting to achieve.
The philosophy will lead to some attributes being more important than others, the choices we deem the more impactful ones will also be documented in this chapter.

\input{chapters/sections/philosophy.tex}

In the following sections different parts of \gls{gamble} will be investigated.

\section{Core syntax choices}

The source code must be written in Unicode, but only the ASCII alphabet and numbers are allowed for names, this is to simplify the parsing. 
The language is case sensitive, this is to avoid programmer errors related to naming. 
Some languages, such as Python, uses whitespace and indentation to indicate scope, in our language scope is indicated by curly brackets \texttt{\{\}}, therefore whitespace is only used to delimit names. 

\subsection*{Comments}
It is useful to be able to write comments in code for annotate meaning.
Both single line and multi line comments can be used in \gls{gamble}. 
``//'' is used for single line comments, meaning that everything after the ``//'' until the next newline is ignored by the compiler, also known as C++ style comments. 
``/* */'' is used for multi line comments, meaning that everything between ``/*'' and ``*/'' is ignored by the compiler, also known as C style comments. 

\subsection*{End of statement terminator}
Some languages use a statement terminator, often a semicolon, this is useful for parsing.
In contrast often the newline terminates statements in other languages.
Having an explicit character terminating statements allows statements to span across multiple lines, without explicitly expressing it in the syntax.
This allows statements to span more than a single line.

\subsection*{Scope}
A variable is in scope from its deceleration until the end of the block it is declared in.
An inner block such as a control flow structure, see \myref{subsec:control-flow} for more, inherits the variables from the outer scope. 
It is also not allowed to redeclare a variable while it is in scope. 
This is to increase the readability of the programs written in \gls{gamble}.
Additionally any function is in scope of any other function including itself, this also allows recursion. 

This is static scoping without information hiding. 

\subsection*{Structure} 
The structure of the source code to a \gls{gamble} program is shown in \myref{lst:Structure}.
Inclusions are gathered in the top, this is to make it easy to get an overview of any and all included libraries. 
Then all function declarations are made, this is to gather all functions. 
Then all the main statements are written. 
This is to separate all the different parts of the program into distinct parts. 
This is also easier to parse and write context free grammar for.  

\begin{lstlisting}[caption={Source code file layout in \gls{gamble}},frame=tlrb,label={lst:Structure}, numbers=none]
Libary inclusions

Function declarations

Statements
\end{lstlisting}

\section{Types and Variables} \label{sec:Types}
%http://www.informit.com/articles/article.aspx?p=2103809&seqNum=3
\gls{gamble} uses three primitive data types; integers (int), floating points (float) and boolean values (bool), as well as two composite data types; matrices and vector. 
In \gls{gamble} any variable must be initialised when it is declared. 
This avoids any null reference which can cause runtime errors in many languages such as C, C\# and Java. 

\subsection*{Integers and floating points}
An integer is a whole number either positive or negative, represented by the two's compliment method. 
Meaning that it ranges from $-(2^{n-1}) $ to $2^{n-1} - 1 $, where n is the number of bits used.
A floating point number is an approximation to a real number. 
It is seperated in 3 parts, the sign bit, the mantissa and the exponent. 
Floats in \gls{gamble} are in base 2, the value of a float is calculated by $ (-1)^{sign bit} \cdot mantissa \cdot 2^{exponent} $. 
Integers and float point numbers default to 32 bits with the keywords \texttt{int} and \texttt{float}. 
It is possible to declare 16 and 64 bit integers and floating point numbers by postfixing their size to their respective keywords, i.e. \texttt{float64} or \texttt{int16}. 
It is useful to be able to specify the size of an integer or a floating point number, as data transfer can cause a lot of overhead particularly when transferring data to and from the \acrshort{gpu}. 

\subsection*{Boolean}
A boolean value is either true or false. 
These are used for control structures in \gls{gamble} which takes a boolean value as a parameter. 
But can also be used for any means which the programmer finds them useful. 

\subsection*{Vectors and Matrices}
A vector in \gls{gamble} is a sequence of entries which are each the same primitive data type. 
The dimension of a vector is immutable, meaning that its dimension cannot be changed after its deceleration. 
In \gls{gamble} there are two types of vectors, row- and column vectors. \todo{argument.}
A matrix is multiple row vectors inside a column vector, each row vector is the same dimension. 
As for other variables both vectors and matrices must be initialised when they are declared. 
This is done with the syntax shown in \myref{lst:matrix}.

\begin{lstlisting}[caption={Creating a matrix},label={lst:matrix}]
matrix<int> m = [1, 0; 0, 1];

rowvector<int> rv = [1, 0];
\end{lstlisting}

\subsection*{Operators}
Available operators in the language can be found on \ref{tbl:operators} with a short description.  
It is not possible to use operators with matrices or vectors, functions which support different operations on these types will be included in a library.
The only operators which work with booleans are the logical ``and'' and the logical ``or''. 
\input{figures/Operators.tex}

\section{Functions}
This section will describe \gls{gamble}'s use of functions. 
Like in many other languages it is possible to declare your own functions in \gls{gamble}.
This is useful for organising code, and reusing parts of the sourcecode.

\subsection*{Function identifiers}
When identifying a function is is required to write the body of the function.
If function identifiers were spread out all over the document it could be hard to find where certain elements of the code were.
In C it is possible to make prototypes of functions in the top of the document, and then declare the bodies of the functions in other places of the document. 
This is not possible in \gls{gamble} because of the increase in readability.
A function identifier is exactly like C, with the \texttt{return type} then the \texttt{functionname}, \texttt{(formal parameters)} and finally \texttt{\{body\}}.
The function body can contain a number of statements and various controlflows.
Furthermore it can contain calls to other functions or calls to the function itself, and hereby recursion is a possibility in \gls{gamble}
An example of a function identifier can be seen on \myref{lst:functionID}.
Other syntaxes could have been used, but not only is this the way C does it, it is also widely used in many other languages like C\# and Java.


\begin{lstlisting}[caption={Function Idemtifier},label={lst:functionID}]                                                        
int add(int a, int b){
	return a + b;
}
\end{lstlisting}

\subsection*{Function calls}
When you have made a function, you need to call the function as well.
This is done again exactly like in C, where you call a function by writing its name followed by the formal parameters in parenthesis.
This is a widely used way of calling functions in many languages just like the identification was.
An example can be seen on \myref{lst:functionCall}.

\begin{lstlisting}[caption={Function Call},label={lst:functionCall}]
add(4, 3);
\end{lstlisting}


\subsection*{Return value}
Functions have a return value which can be seen on \myref{lst:functionID}.
The return values are all the types in \gls{gamble} mentioned in \myref{sec:Types} and then void. 
A void function will not return anything, but instead can be seen as a procedure which manipulates its input, and perhaps prints something.
This choice was made because \gls{gamble} should to be able to return all the different types in the language from a function, but also be able to perform these procedures which a void function may do.
\gls{gamble} assigns return values from a function just like it assigns other values to variables.
The value or type to be returned is preceded by the keyword \texttt{return}, just like it is in C and other C-like languages.
An example can be seen on \myref{lst:returnFunction}.

\begin{lstlisting}[caption={Return Function},label={lst:returnFunction}]
int a = 0;

a = add(4, 3);
\end{lstlisting}

%STD LIB EVT?!
%\subsection*{Premade functions (rename)}\todo{This} 
%\section{Control Flow}
%\textbf{For-loop}
%\textbf{While-loop}
%\textbf{If \& If else}

%% OLD
%\input{sections/subsections/controlflow.tex}
%% New
\input{chapters/sections/subsections/controlflow2.tex}

