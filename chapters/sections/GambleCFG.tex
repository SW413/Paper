\section{Context free grammar in gamble}
Our grammar is written using \acrfull{ebnf}, and uses \acrfull{regex} to define terminals such as numbers and identifiers.
In this section there will be a short traversal of what wil corrospond to one of the parse trees branches.
The full \acrshort{cfg} of \gls{gamble} can be found on \todo{ref til appendix} alongside the lexing rules.
This section only presents a small selection of the entire \acrshort{cfg}.

The first production rule from the \acrshort{cfg} of \gls{gamble} is the statement. 
Looking at \myref{lst:statements} it is seen that a statement can be both an assignment, declaration, functioncall, controlblock or a loop construct. 
Statement productions are the building blocks of sourcecode written in \gls{gamble}.

\begin{lstlisting}[caption={\acrshort{cfg} Statement},frame=tlrb,label={lst:statements},numbers=none]
statement
    : assignment ';'
    | declaration ';'
    | functioncall ';'
    | controlblock
    | loop
    ;
\end{lstlisting}

All the elements in the statement productions expand to each of their own production, hence they are non-terminals.
Looking at the declaration production on \myref{lst:declaration} it see that it have two elements, datatype '=' expression and complexdatatype ID '=' expression.
Each of there are non-terminal since they both have their own production. They both end on the expression production.

\begin{lstlisting}[caption={\acrshort{cfg} Declaration},frame=tlrb,label={lst:declaration},numbers=none]
declaration
    : datatype ID '=' expression                        #primitiveDecl
    | complexdatatype ID '=' expression                 #complexDecl
    ; ;
\end{lstlisting}

Further expanding into the expression production, it is seen that it have five different elements.
The expression can be called in different ways inside the expression itself because there may be a need for several different expressions to be used in the same expression.
Aside the expressions non-terminal there is are an no-terminal value and an no-terminal postUnaryOperator.
\begin{lstlisting}[caption={\acrshort{cfg} Expression},frame=tlrb,label={lst:expression},numbers=none]
expression
    : expression ( '*' | '/' | '%' ) expression     #mulExpr
    | expression ( '+' | '-' ) expression           #addExpr
    | '(' expression ')'                            #parenExpr
    | value                                         #valueExpr
    | ID postUnaryOperator                          #postIDExpr
    ;
\end{lstlisting}
  
The value production expands into what is seen on \myref{lst:value}.
In this production are there both terminals, and non-terminals.
The terminals are elements that have no production, leading to a ``dead end''.
When a terminal is reached it is used and is as a leaf on a tree, also seen in .\todo{Kilde til afsnittet med billeder SÃ¸ren har lavet.}
\begin{lstlisting}[caption={\acrshort{cfg} Value},frame=tlrb,label={lst:value},numbers=none]
value
    : ID                                     #valID
    | constant                               #valConstant
    | '[' valueList ( ';' valueList )* ']'   #valList
    | functioncall                           #valFuncCall
    | collectionEntrance                     #valCollectionEntrance
    | BOOLVAL                                #valBool
    ;
\end{lstlisting}

Going through this small part of the \acrshort{cfg} one single branch of the parse tree have been unfolded and shown.
\gls{gamble}s \acrshort{cfg} is then used in the parser.
The parser takes the input from a lexical analyzer, the source code in the form of a token stream.
The parser uses the \acrshort{cfg}s production rules to set up again the source code to detect any errors in the source.
The output is a parse tree.
This is future explained in \myref{sec:syntaxAnalysis} and \myref{subsec:parser}.
