\section{Context free grammar in GAMBLE}
\gls{gamble}'s grammar is written in \acrfull{ebnf}, and uses regular expressions to define terminals such as numbers and identifiers.
In this section there will be a short traversal of a branch from the parse tree.\todo{Hvad ? hvad betyder det??? - Søren}
The full \acrshort{cfg} of \gls{gamble} can be found in \myref{app:CFG} alongside the lexing rules.
This section only presents a small selection of the \acrshort{cfg}.
\gls{gamble}s \acrshort{cfg} is used in the compiler for parsing a program into a structure, which can be manipulated and analysed to produce the target code for the specific program.\todo{Er det vigtigt ? Kan vi ikke nøjes med at sige at grammatikken skal bruges til en parser for gamble ? Vi forklarede det jo i sidste afsnit ? - Søren .. Enig det er redundant -- Troels}
The production rules are used to check for any syntactical errors which might occur.

A production rule from the \acrshort{cfg} of \gls{gamble} is the statement rule. 
Looking at \myref{lst:statements} it is seen that a statement can be both an assignment, declaration, functioncall, controlblock or a loop construct. \todo{``Looking at .. seen'' er meget talesprogs agtigt, skriv evt. ``Shown in .. are''}
Statement productions are the building blocks of any source code written in \gls{gamble}.

\begin{lstlisting}[caption={\acrshort{cfg} for Statements in \gls{gamble}},frame=tlrb,label={lst:statements},numbers=none]
statement
    : assignment ';'
    | declaration ';'
    | functioncall ';'
    | controlblock 
    | loop
    ;
\end{lstlisting}

All production rules in the statement each expand to their own production hence they are non-terminals.
Looking at the declaration production on \myref{lst:declaration} observe that it has two production rules, \texttt{datatype '=' expression} and \texttt{complexdatatype ID '=' expression}. 
They both end on the expression production which can be seen on \myref{lst:expression}.

\begin{lstlisting}[caption={\acrshort{cfg} for Declarations in \gls{gamble}},frame=tlrb,label={lst:declaration},numbers=none]
declaration
    : datatype ID '=' expression                        #primitiveDecl
    | complexdatatype ID '=' expression                 #complexDecl
    ; ;
\end{lstlisting}\todo{Er denne rigtig i forhold til den nye grammatik der er blevet lavet igennem tiden ? Den opdaterede grammatik skal også sættes ind i appendix - Søren}

Further expanding into the expression production rules, it can be seen that it has five different production rules. \todo{Er der stadig kun 5? -- Troels}
An expression has production rules expanding the expression into a construct containing more expressions.
This is done because an expression can derive to a value, and several values are needed for multiple arithmetic operations.
This construct also causes left-recursion, something often attempted to be avoided in \acrshort{cfg}.
The parse generator \acrshort{antlr} can handle simple left-recursion as seen on \myref{lst:value} and as such it is acceptable in the \acrshort{cfg} for \gls{gamble}.\todo{Måske vi skal have et afsnit inden gamble CFG omkring parse generators eller noget ? :) Det skal bare nævnes et sted - Søren}
It does so internally rewriting it and as such removes the left-recursion.
\begin{lstlisting}[caption={\acrshort{cfg} for Expressions in \gls{gamble}},frame=tlrb,label={lst:expression},numbers=none]
expression
    : expression ( '*' | '/' | '%' ) expression     #mulExpr
    | expression ( '+' | '-' ) expression           #addExpr
    | '(' expression ')'                            #parenExpr
    | value                                         #valueExpr
    | ID postUnaryOperator                          #postIDExpr
    ;
\end{lstlisting}
  
The value production rule can expand into what is seen on \myref{lst:value}.
In this production both terminals and non-terminals are included.
The terminals are elements that have no further production rules, leading to a ``dead end''.
When a terminal is reached it is encountered the deriviation ends and the terminal becomes a leaf on the parse tree, also seen in \myref{sec:AST}.
\begin{lstlisting}[caption={\acrshort{cfg} for Values in \gls{gamble}},frame=tlrb,label={lst:value},numbers=none]
value
    : ID                                     #valID
    | constant                               #valConstant
    | '[' valueList ( ';' valueList )* ']'   #valList
    | functioncall                           #valFuncCall
    | collectionEntrance                     #valCollectionEntrance
    | BOOLVAL                                #valBool
    ;
\end{lstlisting}\todo{Er de rent faktisk terminals ? Er en terminal ikke noget som ikke har en productionrule ? Det har de vel allesammen her ? -- ? .. En terminal er noget som ikke kan udvides men læses direkte, der er ingen her. -- Troels}
\todo[inline]{burde vi ikke beskrive alternative labels aka hashtags? MP .. Måske evt. skrive at de er skrevet til antlr? -- Troels}
