\section{Functions}\label{sec:funcs}
Functions are blocks of code which can be called to do a specific computation, a function can take some variables as inputs or require no input.\todo{skal return value nævnes her? MP}

This section will describe \gls{gamble}'s use of functions. 
Like in many other languages it is possible to declare your own functions in \gls{gamble}.
This is useful for organising code, and reusing parts of the source code.
Functions in \gls{gamble} can take input, but are not required to, the inputs can be any of the types the language supports.
Because of high implementation cost in the compiler, it is not possible to use a function as input for a function.\todo{Compiler - Søren}

\gls{gamble} also has certain functions built into the language for varying reasons.
The most unique function in question here is the \texttt{print} function.
This function is special in the sense that it enables the programmer to use strings as a parameter, a data type otherwise not implemented in the language.
This is enabled to let programmers write messages to the console.
This is both useful for output and debugging the source code.

Other functions provided by \gls{gamble} are created out of convenience.
In object-oriented languages subscripting is common and allows for a wide range of useful features, e.g. \texttt{.GetLength} on arrays in C\#.
Similar to this \gls{gamble} provides the functions \texttt{Rows} and \texttt{Cols} for matrices and vectors which returns their amount of rows or columns.
If called on a vector one can use either rows or columns, it will give the same result.
This can be used in loops to make them iterate over matrices of varying sizes.

%Another such function is \texttt{MakeIntMatrix}.
%This creates a matrix with int values a similar function exists for float.
%These takes three arguments as input, the amount of rows, amount of columns, and what value to place at every entry.
%This function builds upon the syntax for initialising a matrix by providing dimensions rather than input, it merely alters the initialised value depending on the argument provided.
%Other functions are created out of necessity, functions for arithmetics such as multiply and addition also exist, as operators between matrices are not a valid expression.

In order to allow users of \gls{gamble} to use data dynamically and save the result, there exists the functions \texttt{matrixToFile} and \texttt{fileToMatrix}. 
The files which can be used must be of a fixed format, and the output of \texttt{matrixToFile} must be usable for \texttt{fileToMatrix}.
One of the parameters is a string which identifies the file to be used, besides from the \texttt{print}--function these are the only places where strings are allowed in \gls{gamble}.
The other parameter of \texttt{MatrixToFile} specifies which matrix the function should write to file.

A complete list of all available standard functions can be seen on \myref{tbl:funcs} together with a description of each function.
\input{figures/functions.tex}

\subsection*{Function identifiers}
When declaring a \gls{gamble} function one must write the body of the function immediately after.
This is to avoid lookahead which e.g. prototypes in C requires.
A function identifier is exactly like in C, with the \texttt{return type} then the \texttt{functionname}, \texttt{(formal parameters)} and finally the \texttt{\{body\}}. % chktex 36
The function body can contain a number of statements and various control flows.
Furthermore it can contain calls to other functions or calls to the function itself, and hereby recursion is a possibility in \gls{gamble}
An example of a function identifier can be seen on \myref{lst:functionID}.
Other syntaxes could have been used, but not only is this the way C does it, it is also widely used in many other languages e.g. C\# and Java.

\begin{lstlisting}[caption={Function Identifier},label={lst:functionID},numbers=none]                                                        
int add(int a, int b)
{
    return a + b;
}
\end{lstlisting}

\subsection*{Function calls}
After a function has been declared it can be called. 
A function call contains the identifier and parameters for the function. 
The syntax in \gls{gamble} is the same as in many other programming language and shown in \myref{lst:functionCall}. 

\begin{lstlisting}[caption={A function call in \gls{gamble}},label={lst:functionCall},numbers=none]
add(4, 3);
\end{lstlisting}


\subsection*{Return value}
Functions have a return value which can be read in its identifier shown in \myref{lst:functionID}.
The return values can be all the types in \gls{gamble} mentioned in \myref{sec:Types} and also void. 
A void function will not return anything, but instead can be seen as a procedure.
This choice was made because \gls{gamble} should be able to return all the different types in the language from a function, but also be able to perform certain procedures without returning anything, such as printing.
The value or type to be returned is preceded by the keyword \texttt{return}, just like it is in C and other C-like languages.
An example can be seen on \myref{lst:returnFunction}.

\begin{lstlisting}[caption={Return Function},label={lst:returnFunction},numbers=none]
int a = 0;
//Add returns an integer
a = add(4, 3);
\end{lstlisting}

\todo[inline]{Kører vi pass by reference eller pass by value? ref for mat/vec or val ellers? -- TK}


%\subsection*{Print function}\todo{rename maybe}\todo{skal flyttes op til de andre funktioner?}
%In \gls{gamble} we have one function that is ready-made. It is a print function.
%The function is special because it can both take variables, numerical values and strings as input parameter.
%Since string is not a valid data type in \gls{gamble} this function is special. 
%With the print function it is possible to give the user a visual representation of the computations result, in the console.                   