\subsection*{Design}
The second important part of the contextual analysis phase for the compiler is the type checking, which enforces the type system of \gls{gamble}.
As \gls{gamble} is statically typed it is necessary to check if all references to identifiers and constant values fit into the context they exist in. 
Since implicit conversion between floating point and integer types is not a part of \gls{gamble} an error must be issued everywhere they are used wrongly. 
It is however possible to implicitly convert between integer and floating point types internally e.g. from int16 to int64, as long as the destination variable is of a larger bit-width.
This is also the case for complex datatypes, matrices and vectors, e.g. from \texttt{matrix<float>} to \texttt{matrix<float64>}. 

The symbol table is used as a reference for which type the variable is, and therefore the type checking happens after the symbol table has been filled, hence after scope checking is completed. 
Type checking is done in many parts of the code, one or more times for each line is common. 
For every operator it must be checked if its types match and if it results in an assignment if that also matches.
Every function call must match the formal parameters of the function. 

The errors produced by the type checker are: Argument errors and type mismatch errors.
An argument error indicates that the number of arguments in the function declaration does not match the number of arguments provided in the function call.
A type mismatch error is caused by a value or identifier not being compatible (type safe) with the function parameters, operator used etc.
Examples are shown in \myref{lst:typeErrors}.

\begin{lstlisting}[caption=Examples of type errors in \gls{gamble},numbers=none,frame=tlrb,label={lst:typeErrors}]
/* [...] */
int a = 1 + 2;      /* Valid */
float b = 2.2 + 1;  /* Type mismatch error */
float c = 2;        /* Type mismatch error */

a = 2.2;            /* Type mismatch error */
b = foo(1);         /* Argument error (Takes more or fewer arguments) */ 
/* [...] */
\end{lstlisting}

\subsection*{Implementation}
The type checker is called right after the \texttt{SymbolTableFillVisitor}.
Since \gls{gamble} has static typing, the type checker is implemented under the contextual analysis, a type checker could also check on runtime, \gls{gamble} do this with vectors and matrices, but most of the type checking happens in the contextual analysis.
To implement type checking \gls{gamble} a visitor is used during the contextual analysis.
The class \texttt{ASTTypeCheckVisitor} visit every node relevant node in the \acrshort{ast} to check for type errors.
The class collects an array of every type error it finds, these errors is then presented to the user, when a compilation fails.
Errors and error handling are further described in \myref{subsec:DesignErrorHandling}.
The class \texttt{ASTTypeCheckVisitor} overrides visitor calls from the \texttt{baseASTVisitor} class.
The visitor does this in multiple places in the \acrshort{ast} and the visitor uses a class \texttt{TypeChecker}, which through function calls on the variables in the nodes.
\texttt{TypeChecker} contains a function, \texttt{CombineValueTypes} which takes two values and checks if they are type compatible.
\texttt{ASTTypeCheckVisitor} visit nodes which contains either one or more variables which could contain type errors.
An example of this is seen in \myref{lst:typecheck1} where the function \texttt{VisitExpressionNode}
 is shown.
The function visit an \texttt{ExpressionNode} and calls \texttt{CombineValueTypes} with the nodes left and right values if there are any available else it send \texttt{null} as the input value.
The function returns a variable of the type returned be \texttt{CombineValueTypes} and string which is printed if the visit finds type errors.

\begin{lstlisting}[caption=The VisitExprressionNode function in the ASTTypeChecker class,numbers=none,frame=tlrb,label={lst:typecheck1}]
public Variable VisitExpressionNode(ExpressionNode node) {
    ValueType valueType = TypeChecker.CombineValueTypes(
            node.getLValue() != null ? visit(node.getLValue()) : null,
            node.getRValue() != null ? visit(node.getRValue()) : null,
            errors,
            node.getLineNumber()
    );
    node.setValueType(valueType);

    return new Variable(valueType, "Expr:<" + node.toString() + ">");
}
\end{lstlisting}

After the type checker have checked every variable in the source code, the compiler scans for unused variables and thereafter prints all the errors in the program, if any.