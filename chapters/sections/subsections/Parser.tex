\subsection*{Parser}\label{subsec:parser}
The parser is based on formal syntax specifications such as a \acrfull{cfg} written in \acrfull{ebnf}, whose alphabet consists of tokens produced by the lexer. 
The parser reads tokens and groups them into phrases according to the syntax specification.
The parser verifies the syntax, and if a syntax error is found it provides a corresponding error message. \citep{Crafting_book}
By using a parser generator like ANTLR or SableCC, handling of syntactic errors and repairs can be done automatically.
A parser can also be written manually but doing so can result in syntactic errors that are hard to locate or solve.
We have chosen to use ANTLR to generate our parser.

There are different kind of parsers, most common are bottom-up and top-down parsers.
ANTLR makes a top-down parser, more specific a recursive descent parser.
A recursive descent parser is a subtype of top-down parser build from a set of mutually recursive procedures where each such procedure usually implements one of the productions of the grammar.
The structure of the resulting program closely mirrors the grammar it recognizes. \citep{Recursive_programming}

The parser outputs a parse-tree which is an alternate representation of the input source-code. 
This also verifies if the input is syntactical valid, but not type and scope checking which is done later in the contextual analysis phase. 

%The second stage of the parser is the actual parser.
%The parser is fed a stream of tokens to recognise a sentence structure and in turn outputs the structure to a parse tree.
%The parse tree records how the parser recognises the structure of the input and its components.
%The parse tree that ANTLR provides contains information about how the parser have grouped the tokens into more abstract languange definitions such as expressions and statements.
%Where previous versions of ANTLR have also implemented the AST, it is not contained in ANTLR V4 instead the parse tree provided by ANTLR have been used to generate an AST this is discussed in \myref{sec:AST}.
%This tree is a trimmed version of the parse tree, where the less informative data have been removed, this makes it easier to read, and thus easier to use throughout development of the rest of the compiler.

%2nd stage is the actual parser, feeds of tokens to recognize sentence structure
%Parse tree records how the parser recognized structure of input and its component phrases
%Trees provide an easy to walk data structure that will be helpful for the rest of the compiler
%2.2 Implementing Parser - Recursive descent
%Recursive-descent parsers are really just a collection of recursive methods, one per rule.
%Such a rule may look similar to this
%// assign : ID ``='' expr ``;'' ;
%void assign() { // method generated from rule assign
%match(ID); // compare ID to current input symbol then consume
%match('=');
%expr(); // match an expression by calling expr()
%match(';');
%}
%Descent refers to the fact we start from the root and go down to the leaves(tokens)
%Reursive descent is just one form of top-down parsers.					NOTE topdown/bottom up parsing
%The call graph traaced out by invoking methods, mirrors the interior parse tree nodes
%To Build a parse tree manually one would insert ``add new subroot note' operations at the start of each rule, and a ``add new leaf node'' operation to match()
%The assign method checks if all necessary tokens are present and in the right order. When the parser enters assign it doesnt have to choose between more than one alternative. An alternative is one of the choices on the right side of a rule def. A parsing method for such rule would be a switch which looks for what token is present.
% This is called a parising decision or prediction by examining next token
%This is where lookahead comes into play , the lookahead token is the next input token, this can be any token the parser "sniffs" before consuming
%This is one of the places where ANTLR is an especially handy tool to use, because ANTLR allows for more lookahead than other parser generators.
%Most parsers use a lookahead of one which LL(1) or LR(1), ANTLR tones the lookahead up and down depending on what token stream it is trying to decode, as such the ANTLR has a lookahead of LL(*)
%ANTLR Solves simple ambiguity simply by using the first mentioned rule.
%AST only useful, Parse all artifacts(space, brackets and so on)

\subsubsection*{Traversing the Parse-Tree}
When working with trees traversing those trees is an important part of the software.
For this task different approaches can be taken, a common way is to implement design patterns, the visitor pattern is particularly popular for tree traversal.
Alternatively one can implement the composite pattern or choose to implement no pattern at all, but simply create a case analysis for each object.

The use of a design pattern is not a requirement for the creation of a compiler.
Design patterns provide solution templates for software problems, each pattern providing its own benefits.
In OOP design patterns are typically aimed at helping object generation and interaction.
However the most important thing to keep in mind when using a design pattern, is not its exact implementation of classes and methods, but the concept the pattern describes.

The two beforementioned patterns belong are classified under two different branches of patterns.
The composite pattern is a structural pattern where as the visitor pattern is a behavioural one.
A structural pattern provides a way of defining the relations between objects, the composite pattern is used to create a hierarchiral recursive tree structure of related objects that may be accessed in a standardised manner.
A behavioural pattern is instead used to define how the objects communicate, the visitor pattern is used to seperate a set of structured classes from any functionality that should be performed upon them.
For the compiler developed with this paper the visitor pattern have been implemented for the traversal of trees as such the pattern is described further in \myref{subs:visit}.  