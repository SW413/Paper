\subsubsection*{Using SimpleOpenCl}
SimpleOpenCL is a library which simplifies the process of setting up and launching a kernel for OpenCL.
The kernels remain the same, but finding the hardware for executing the kernels and also allocating memory for the hardware is simplified.
The compiler starts the codegeneration by calling an instance of the class \texttt{CodeGenerator} and invoking the method \texttt{GenerateCodeAndWriteToFile}.
This method then makes the \acrshort{ast} accept a CodeGeneratorVisitor, and writes its output to a file while also exporting the outputcode to a certain directory along with other files needed like the OpenCL kernels used in the program.
The \texttt{outputCode} is a string which starts as an empty string, and every visitor then either appends or returns substrings to be appended containing different information to the string as the traversal of the \acrshort{ast} is ongoing.
The codegeneraterVisitor starts at the root of the AST and here the code on \myref{lst:OpenCLSetup} is run.

\begin{lstlisting}[caption=Call to setup SimpleOpenCL in the compiler,numbers=none,frame=tlrb,label={lst:OpenCLSetup}]
outputCode.append(filesNstuff.
	 ImportStringFromResource("codesnippets/simpleCLsetup.c") + "\n\n");
\end{lstlisting}

The file simpleCLsetup.c is apended to the code right as the main method of the output file is started.
The file contains the code which can be seen on \myref{lst:OpenCLSetup2}.

\begin{lstlisting}[caption=SimpleOpenCL setup in the compiler,numbers=none,frame=tlrb,label={lst:OpenCLSetup2}]
/* Simple-OpenCL Hardware setup  */
	sclHard* allHardware;
	sclHard hardware;
	sclSoft software;
	int found = 0;
	allHardware = sclGetAllHardware( &found );
	hardware = sclGetFastestDevice(allHardware, found);

    size_t local_size[2];
    size_t global_size[2];

    printf("\n");
/* END Hardware setup */
\end{lstlisting}

This code creates the elements needed to launch a kernel. 
It finds the fastest hardware according to SimpleOpenCl which means it finds the device with the most number of compute units, no matter the type of device, be it a CPU or a \acrshort{gpu}.
For the remaining part of this section the fastest device is a \acrshort{gpu}.
\texttt{global\_size} and \texttt{local\_size} are there to determine the amount of memory needed both globally and locally on the \acrshort{gpu}.
These arrays are then filled out with different numbers corresponding to the columns and rows of the matrices or vectors being calculated upon.
This way of appending templates to the outputCode string is used in different places in the code generation when handling the complex datatypes matrices and vectors.
In fact whenever one of the following operators \texttt{+ , - , * , \# , \^ } are used with matrices or vectors a template is being appended to the outputCode.
See \todo{inds√¶t myref} for a description of what each operator will produce in gamble.

When an assignment's rightside or a declaration's rightside consists of an expression using operators and matrices or vectors, the visitor's check for which operator is used and then inputs a launch kernel template depending on the operator.
The compiler contains files which have the code for launching the kernel for the specific situation and also for the kernel itself.
If a kernel is used the kernelfile is added to the codeout directory along with the outputCode itself.

\myref{lst:kernelLaunch} shows one of the kernels being appended to the outputCode.

\begin{lstlisting}[caption=SimpleOpenCL launch of a kernel calculating a matrix multiplied with a scalar.,numbers=none,frame=tlrb,label={lst:kernelLaunch}]
//MATRIX \SMATRIX_A\S MULTIPLIED WITH A SCALAR \SMATRIX\_B\S
global_size[0] = \SMATRIX_A\S.rows*\SMATRIX\_A\S.cols;
local_size[0] = 1;
global_size[1] = 1;
local_size[1] = 1;
software = sclGetCLSoftware("matrixMulScalar.cl", "matrixMulScalar", hardware);
\SMATRIXTYPE\S scl_scalar_mul\SNUM\S = \SMATRIX_B\S;
sclManageArgsLaunchKernel(hardware, software, global_size, local_size, "%R %a",
    \SMATRIX_A\S.dataSize, \SMATRIX_A\S.dataStart, sizeof(\SMATRIXTYPE\S), &scl_scalar_mul\SNUM\S);
//END MATRIX SCALAR MULTIPLY
\end{lstlisting}

Before this code is appended any string with a \S


