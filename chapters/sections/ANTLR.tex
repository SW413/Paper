\section{Implementation}
The syntax analysis is implemented through the tool \acrfull{antlr}, this tool provides some advantages over other available tools.
\acrshort{antlr} is based upon a parser technique called LL(*).
LL(*) uses an algorithm to have a varying lookahead when needed.
The LL(*) parser technique allows a bigger class of \acrshort{cfg} than ordinary parser techniques like LL(k).\todo{Større end hvad? og hvad er en class of CFG?}
In the most recent version of \acrshort{antlr} as time of this publication, \acrshort{antlr} 4, the underlying algorithm have been extended to a parser technique called Adaptive LL(*) (ALL(*)).
The most important feature of ALL(*) is that it moves grammar analysis to parse time.\todo{to parse time? Hvor kommer dette udtryk fra?}
This lets the parse algorithm accept any non-left-recursive productions.\todo{Men det er jo det modsatte(altså at den kan acceptere left-recursive productioner) som gør den speciel}
The ALL(*) approach accepts a broader class of grammars than most other parsing methods, one way this is done is to rule out ambiguity by using a rule of precedence.\todo{Class of grammers?}
If a grammar is ambiguous the ALL(*) approach will take the first  available rule in the \acrshort{cfg} and apply it.
This allows for a less strict \acrshort{cfg} and while most grammars could be rewritten to be unambiguous without applying the precedence rule, this allows the designers of languages grammars to edit existing grammars without rewriting as much a could be required if the precedence rule was not available.	
The idea with the ALL(*) algorithm is that the grammar is analysed dynamically at runtime rather than statically, before executed by the generated parser.
This allows \acrshort{antlr} access to input sequences while reading through the grammar, meaning not all possible inputs must be considered.
Due to this dynamic analysis \acrshort{antlr} 4 is able to handle some ambiguous constructs and reduce-reduce conflicts.
As mentioned this allows \acrshort{antlr} to take care of left-recursion if such is present in the grammar by rewriting it, as such would be the case in \myref{lst:amb}.

\begin{lstlisting}[caption=An ambiguous rule for expr,frame=tlrb,label={lst:amb}]
expr : expr '*' expr 	// match expressions with * operator
     | expr '+' expr 	// match expressions with + operator
     | INT 		// matches simple integer
     ;
\end{lstlisting}

%While it may not be obvious from \myref{lst:amb} but this CFG also implements \acrshort{antlr}s way of representing operator precedence by simply obeying the first alternative in the rule set, as such the multiplication operator (``*'') will have the higher precedence. - Dette står allerede tidligere
The ALL(*) algorithm also means that one can completely disregard lookahead and it will still be able to parse, although one should keep in mind that having more lookahead than necessary will slow down the process.
The scanner provided by \acrshort{antlr} groups related tokens into token types such as INT, ID and FLOAT.
In \acrshort{antlr} a token contains at least two pieces of information, the token type and the matched text for the token.
\acrshort{antlr} also implements rule element labels in its \acrfull{cfg} which means one can apply label rules to a construct in a grammar, this allows for conditional steps in the grammar based on the source code being parsed.
Furthermore \acrshort{antlr} can set up an interface and base implementation of the visitor pattern for the parse tree on a given grammar by running \acrshort{antlr} with the \texttt{--visitor} flag.\citep{ALLSTAR, LLSTAR, antlr4_Book}


