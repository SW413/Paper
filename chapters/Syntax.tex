\chapter{Syntax}\label{chap:syntax}

To describe the formal syntax of \gls{gamble}, and to parse the language, it is necessary to write a \acrfull{cfg}.
This chapter will explain what a \acrshort{cfg} is, and the problems encountered while creating one.
After this an explanation of \gls{gamble}'s \acrshort{cfg}, will be presented.

\section{Context-Free Grammar}\label{sec:cfg}
A \acrshort{cfg} is a set of formal languages which are useful for specifying syntax. \todo{Det er vist ikke helt rigtigt :P ? - Søren}
A \acrshort{cfg} consists of one or more production rules.
On the left side of a production rule is a non-terminal and on the right side are terminals and/or non-terminals, additionally there is a start symbol.
An example of this is written in \myref{lst:cfglst1}, where a definition for multiplication and addition with parenthesis is shown.
The expression production on this figure uses left recursion, since an expression has a production which first element is also an expression.
The grammar is structured such that the multiplication operator have a higher precedence than the addition operator, because \texttt{term} is located before the \texttt{+} symbol.\todo{* symbol? MP}

\begin{lstlisting}[caption={An example of a \acrshort{cfg} written in \acrshort{ebnf}, with \acrshort{regex} for defining numbers. },frame=tlrb,label={lst:cfglst1},numbers=none]
expression = term | expression "+" term;
term       = factor | term "*" factor;
factor     = constant | "(" expression ")";
constant   = [0-9]+
\end{lstlisting}

It is possible to generate a parse tree for a string which follows the grammar.\todo{første gang parse tree nævnes - Marc. Foreslår at introducere parse træ her, bare forklare hvad det er da det giver god mening at have det her."A parse tree is a tree which shows the derivation for a string from the start symbol of the \acrshort{cfg} until all the leafs of the tree only contains terminal of the \acrshort{cfg}. In compilers and interpreters this is done using what is called a parser, which is a program that transforms strings into parse trees. This will further be explained in \myref{sec:parsetrees}" - Søren -- God formulering +1 dog står noget ligende senere \myref{sec:parsetrees} -- Troels} 
If there exists two or more parse trees for any given string then the grammar is ambiguous. 
Having an ambiguous grammar can be a problem when parsing because the one cannot always decide which grammar rule it should apply. \todo{``the one'' hvad? -- Troels}

\subsection{The dangling else problem} \todo{Er der nytte af dette afsnit? -- Troels}
This section shows an example of how to solve the problem of ambiguity for grammars. 
Some tools for generating parsers from grammars, can solve these problems themselves.
One of these tools, \acrshort{antlr}, will be discussed later in \myref{sec:ANTLR}.\todo{Er det vigtigt at nævne Antlr her ? - Søren Nej MP}

A common mistake leading to ambiguous grammar is the dangling else problem. \citep{danglingelse}
In many programming languages it is possible to have an if statement and an else statement, and inside the body of these also having if- and else statements. 
A \acrshort{cfg} describing it is shown in \myref{lst:danglingelseex1}.

\begin{lstlisting}[caption={An example of a \acrshort{cfg} describing an if statement. \citep{danglingelse}},frame=tlrb,label={lst:danglingelseex1},numbers=none]
if statement =
    | if clause statement
    | if clause statement else statement

statement =
    | simple statement
    | if statement
    | loop statement
\end{lstlisting}

Given an input where the statement of an if statement contains another if statement this grammar is ambiguous.  
However it can be rewritten to allow if-else statements in a grammar, yet this will in almost all cases cause the size of the grammar to increase. 
A solution to this problem is to observe that there exists two kinds of if statements, open and closed if statements.
An open statement is one in which the if statement is not paired with an else, and a closed statement is any if statement paired with an else.
A simple statement is also a closed statement.
A simple statement is any regular statement, i.e. assignment.
A grammar resolving the dangling else problem using this method is shown in \myref{lst:danglingelseex2}.

\begin{lstlisting}[caption={An example of a \acrshort{cfg} describing an if statement, that is not ambiguous. \citep{danglingelse}},frame=tlrb,label={lst:danglingelseex2},numbers=none]
statement =
    | open statement
    | closed statement

open statement =
    | if clause statement
    | if clause closed statement else open statement

closed statement =
    | simple statement
    | if clause closed statement else closed statement
\end{lstlisting}

Another way to resolve this issue is to force statement bodies of if statements, when followed by an else statement, to be delimited by explicit blocks, such as \texttt{begin..end} used in Pascal or curly brackets (\texttt{\{\ldots\}}) used in C and derivatives. 

\subsection{Derivations of parse trees}\label{sec:parsetrees}
A parser is a program which takes a string of symbols, and parses it into segments according to the rules specified in a grammar.
A more thorough explanation of parsers and specifically the one implemented for this project can be found in \myref{subsec:parser}.
Two common strategies to generate a parse tree is leftmost derivation and rightmost derivation. 
A leftmost derivation applies the rules in the grammar by always applying a production rule to the leftmost non-terminal. 
This is the strategy used in a top-down parser, also known as an LL parser.
A rightmost derivation is the reverse, and what is used in a bottom-up parser, also known as a LR parser.
An LL is a subset of LR, and as such an LR parser can also parse LL languages. 

\section{Classes of CFGs}
As mentioned there are two common strategies for parsing, leftmost and rightmost. 
A parser has a lookahead which is the maximum numbers of tokens which are needed to determine what rule should be applied, this is denoted in a parenthesis, so i.e. LL(1) means leftmost derivation using a lookahead of 1 token. 
A lookahead of k means that there is a constant lookahead of a maximum of k tokens for the given parser. 
LL(*) is also a grammar class, which can dynamically change the number of tokens needed to parse by recognizing if they follow a \acrlong{regex}.
An LL parser is called an LL(*) parser if it is not limited to finite k tokens of lookahead, but can make parsing decisions by recognizing whether the following tokens belong to a regular language.
Combining this with the fact that any LL grammar is a subset of an LR grammar and the different cases of lookahead constructs a diagram. 
This Venn diagram is shown in \myref{fig:hierarchyofgrammars}, LL(*) can express the same grammars as LL(k).
This figure also contains the Simple LR (SLR) which is broader definition of grammar than an LR(0) grammar, but less so than an LR(1), and the LALR(1) which covers more grammars than Simple LR and less than LR(1). \todo{Det her giver mening, men har 0 relevans og lyder rigtig dårligt :P, måske bare stoppe efter " LL(*) can express the same grammars as LL(k)." - Søren}
\begin{figure}[!ht]
\centering
 \includegraphics[width=0.5\textwidth]{figures/classesofgrammars.png} % trim=4.85cm 15cm 0.85cm 1cm
\caption{A Venn diagram showing the similarities between the different subclasses of CFGs. Where LL(*) is marked with in light blue. \citep{Lecture5}}
\label{fig:hierarchyofgrammars}
\vspace{-15pt}
\end{figure}
\input{chapters/sections/GambleCFG.tex}