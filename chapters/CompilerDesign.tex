\chapter{Compiler Overview}\label{Chp:CompilerOverview}
When creating a compiler there is two basic ways of compilers one can create, a multi-pass compiler or a single-pass compiler.
Each have their advantages and disadvantages however the most significant difference is that in a single-pass compiler, as the name suggests, only one pass is done.
This highly limits the information available to the compiler and this decreases the odds of creating efficient programs, which is not wished for in \gls{gamble}.
As such this compiler will be a multi-pass compiler, such a compiler can be divided into phases.
In this chapter the different phases of the compiler and their goals and tasks will be presented, to give an overview for the chapters to come.

The compiler for \gls{gamble} is separated into three phases: syntax analysis, contextual analysis and code generation.
\myref{fig:phases} shows a state diagram of the phases of the compiler.
Syntax analysis and contextual analysis transforms the source code into an intermediate representation, and verifies the source code according to the specified syntax from the \acrshort{cfg}, and also for type and scope checking.
The choice of language for writing the compiler falls upon Java 1.8, which is also the language the project group have been taught for building compilers in the courses for the semester.
When making a compiler an object-oriented language simplifies many tasks, because of encapsulation, polymorphism and inheritance. 
The paradigm allows for many structural options, and reuse of code when inheriting, which would be impossible using another paradigm like imperative or functional programming.
Java also works across platforms, which is a useful feature.

In the syntax analysis phase the input source code is parsed and separated into tokens according to the \acrshort{cfg}.
This is the scanner's job, the parser structures these tokens into a tree structure, which can be traversed in the order of the source code.
When the source code has been parsed the tree is then simplified to remove unnecessary information such that a tree with less nodes is to be traversed.

In the contextual analysis phase the tree is used to generate a table, containing all the variables and functions which is declared in the source code.
This is called a symbol table, and it is used to check if the variables and functions called and used in the source code are in scope, and also if they uphold the type rules of \gls{gamble}.
This phase results in telling the programmer if a mistake is found in the source code and where the mistake is located, and also what is wrong, but it also results in the tree now containing additional information about the type of expressions in the source code.

The last phase of the compiler is code generation and optimizing.
Optimization is any process which will make the generated program faster, e.g. adding constant numbers before the runtime etc, or changing the order of access to matrices to increase locality. 
In the code generation phase the output code is generated from all the information in gathered from the previous phases of the compiler.

The target language of this compiler is OpenCL C.
To compile OpenCL C code additional software for the GPU is required, depending on the machine the path to this software may be required when compiling, as such one cannot simply run this on all machines.
By compiling the OpenCL C code, it is translated into the computer's instruction set and then further into machine code, which the computer understands.
This is an abstraction made by the project group to simplify the process of generating code, as targeting the \acrshort{gpu} using the specific instruction set, not only gives problems targeting more types of GPUs but is also way too demanding for the project group to understand let alone use in just one semester.
Using OpenCL C, the target language is still low level compared to Java or C\#, and C has even been characterised as a portable assembly language.\citep{CPort}

\begin{figure}
\centering
\includegraphics[width=0.5\textwidth]{figures/ClassDiagrams/CompilerDiagram.pdf}
\caption{State diagram showing the phases of the compiler when it takes \gls{gamble} source code and compiles it into machine code.}\label{fig:phases}
\end{figure}


%\begin{figure}[ht!]
%	\centering
%	\begin{tikzpicture}[node distance = 2.5cm]
%		\node (invi1) 		[invi,draw=none] {GAMBLE Source code};
%		\node (syntax) 		[blockz, below=0.6cm of invi1] {Syntax Analysis};
%		\node (contextual) 	[blockz, below of=syntax] {Contextual Analysis};
%		\node (codegen) 	[blockz, below of=contextual] {Code Generation};
%		\node (opencl) 		[invi,draw=none, below=0.6cm of codegen] {OpenCL C code};
%
%		\node (error1) 		[cloud, right=1cm of syntax] {Error reports};
%		\node (error2) 		[cloud, right=1cm of contextual] {Error reports};
%
%		\node (invi2) 		[invi,draw=none, below=0.4cm of syntax] {};
%		\node (ast) 		[invi,draw=none, right=-0.2cm of invi2] {Abstract Syntax Tree};
%
%		\node (invi3) 		[invi,draw=none, below=0.4cm of contextual] {};
%		\node (dast) 		[invi,draw=none, right=-0.5	cm of invi3] {Abstract Syntax Tree \& Symbol Table};
%
%		\draw [arrow] (invi1) -- (syntax);
%		\draw [arrow] (syntax) -- (contextual);
%		\draw [arrow] (contextual) -- (codegen);
%		\draw [arrow] (codegen) -- (opencl);
%		
%		\draw [arrow] (syntax) -- (error1);
%		\draw [arrow] (contextual) -- (error2);
%	\end{tikzpicture}
%	\caption{The phases of the compiler.}\label{fig:phases}
%\end{figure}
\clearpage

\input{chapters/sections/subsections/SourceCodeAsTrees.tex}

\chapter{Syntax Analysis}\label{sec:syntaxAnalysis}
Syntax analysis is the first phase in compiling a language.
In this phase it is checked whether the input adheres to the rules of the language.
These rules are defined in a languages' \acrshort{cfg}.
The \acrshort{cfg} of \gls{gamble} is further described in \myref{sec:cfg}.
This analysis can be split up into further sub phases, lexical analysis and parsing, these are described in this chapter.
\section{Design}
%Design
\input{chapters/sections/subsections/Scanner.tex}
\input{chapters/sections/subsections/Parser.tex}
\input{chapters/sections/subsections/AST.tex}
\input{chapters/sections/subsections/TraversalOfTrees.tex}
\input{chapters/sections/subsections/VisitorPattern.tex}

%Implementation
\input{chapters/sections/ANTLR.tex}
\input{chapters/sections/CreatingtheAST.tex}

%Subphases
\chapter{Contextual Analysis}
Once the source code has passed through the syntax analysis, and thereby is validated in regard to the \acrshort{cfg}, it must be checked for contextual errors.
In the contextual analysis phase semantic errors are the ones being checked for, this includes type errors such as type mismatch, e.g. adding a boolean to a float, which may well be using the correct grammar, but is not a valid arithmetic expression.
In the contextual analysis there is also checked in which scopes the different variables is available and if there is errors of this type.
The design and implementation of the contextual analysis as well as how such errors are handled are described in this chapter.
%\input{chapters/sections/ContextualAnalysis.tex}
\input{chapters/sections/subsections/SymbolTable.tex}

\section{Scope Checking}
As a part of the contextual analysis the compiler must ensure that every reference is valid in their given scope.
The validity of such reference is specific to the rules of the language, this section describes how the compiler upholds the rules listed in \myref{subsec:Scope}.
\input{chapters/sections/subsections/ScopeCheck.tex}

\section{Type Checking}
\input{chapters/sections/subsections/TypeCheck.tex}

\section{Error Handling}
\input{chapters/sections/subsections/ErrorHandling.tex}

%Phase3
\input{chapters/sections/CodeGeneration.tex}
\section{Design}
\input{chapters/sections/subsections/GPUCode.tex}
\input{chapters/sections/subsections/Optimisation.tex}
\section{Implementation}
This section will show examples from the code which generates the output code from the files written in \gls{gamble}.
This will give a greater understanding of how some of the design choices made in the previous section are implemented in the compiler.
In the following text an introduction of a library called SimpleOpenCL will take place.
\input{chapters/sections/subsections/Templates.tex}
\input{chapters/sections/subsections/MakeFile.tex}
